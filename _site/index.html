<!DOCTYPE HTML>
<html lang="en-US">
<head>
    <meta charset="UTF-8">
    <meta name="google-site-verification" content="uPo9ejFsAXhqlhxbsrVtWkBWHQQDUGvP5lSSqj5Mb54" />
    
    <title>MATTENOBLE - Ruby, Software Development and other Stuff.</title>
    
    <link rel="stylesheet" type="text/css" href="/public/css/main.css" media="all">
    <link rel="stylesheet" type="text/css" href="/public/css/clouds.css" media="all">
    <script type="text/javascript" src="http://use.typekit.com/npn1una.js"></script>
    <script type="text/javascript">try{Typekit.load();}catch(e){}</script>
</head>
<body>
    <div id="wrap">
        <h1>
            <a href="/">
                <p>MATTENOBLE</p>
                <img src="/public/images/gem.png" alt="rubygem" />
                <div style="clear:both;"></div>
            </a>
        </h1>
        
        <div id="content">
            <div id="articles">
                
<div class="article">
    <h2><a href="/2011/04/02/value-of-it-just-working/">Taking Care of Business</a></h2>
    <p>One of the many things I love about the Ruby community is the notion that things should &#8220;just work&#8221; out of the box. I&#8217;m sure it&#8217;s in part due to Rails&#8217; convention over configuration mentality, but I think it&#8217;s more than that.</p>
<p>During the day I wear skin tight, rockstar style snake skin pants. If you aren&#8217;t picking up on my odd, far-reaching metaphor, I mean I write Python code. Anyway, it may just be a lack of experience in the community but things seem infinitely more complicated to get up and running than when I&#8217;m working with Ruby. It just feels like there is more between me and the end goal.</p>
<p>Here&#8217;s a few of my favorite pieces of &#8220;just works&#8221; Ruby software:</p>
<h3>Devise</h3>
<p><code>rails g devise:install</code> and <code>rails g devise user</code> Done. You&#8217;ve got a sign in page, a user model, migration and all the goodness. I just wrote the steps for adding authentication to an app in a single sentence. That&#8217;s incredible.</p>
<h3>Heroku</h3>
<p>Heroku is another great example that literally takes seconds to get up and running with. <code>rails new blog</code>, <code>heroku create</code>, <code>git push heroku master</code>. Done &amp; done. Application deployed and online.</p>
<h3>Rubygems</h3>
<p>So you have a gem you want to make available to the world? Simple, <code>gem build whatever.gemspec</code> and <code>gem push whatever-0.0.1.gem</code>. Done. Granted, I do know this one has a Python equivalent. <code>python setup.py register</code> claims to get you the same, but my recent attempts have all failed with, &#8220;You are not allowed to store &#8216;whatever&#8217; package information&#8221;. Okay.. so.. what now?</p>
<p>Tools are an important part of any developers day to day life. I think tools are partially why Ruby developers are typically quite productive. We see the value in good development tools and we spend time crafting them to &#8220;just work&#8221;.</p>
<p>This is only one of the many things I admire about the Ruby community, but it&#8217;s an important one. Having efficient tools helps make an efficient developer.</p>
</div>

<div class="article">
    <h2><a href="/2011/03/30/TADDD/">Test and Design Driven Development</a></h2>
    <p>For quite some time the way I&#8217;ve worked was to develop the application as if the interface didn&#8217;t matter, until it was done. Write my features, tests, etc and then when you have a functioning 1.0, slap some pretty on it. It always felt wrong, it felt unfair to the application.</p>
<p><a href="http://rubylearning.com/blog/2010/10/05/outside-in-development/">Outside-In Development</a> is pretty awesome but while it ends up being great for features and application code, it didn&#8217;t seem right for mixing in some design work. I&#8217;ve altered the my general, outside-in, workflow to include some design time. Here&#8217;s how it goes..</p>
<h3>Cucumber</h3>
<p>Write a feature; keep it high level and based on value (you already know this though). Lets say you&#8217;re working on the Authentication portion of your application. You want to make sure when a user signs in, they are greeted with the message &#8220;Hey there!&#8221;.</p>
<h3>RSpec, MiniTest, etc.</h3>
<p>Write some controller and model tests to get rolling with the lower level login stuff. Let&#8217;s pretend you just did that. A user can sign in and they will in fact see &#8220;Hey there!&#8221;. That&#8217;s awesome, nice work. Except&#8230;</p>
<p><img src="/public/images/taddd/crap-login.jpg" title="ugly login screen" alt="ugly login screen" /></p>
<p>Gross. You could leave it like this for the time being and move on to other features if you so incline. I, however, can not do that anymore. Having a functioning app with a lame UI sounds as bad as having no app at all to me.</p>
<h3>Design</h3>
<p>At this point, it&#8217;s time to put a little shine on your application. If you&#8217;re not doing both design and development you could probably even &#8220;get lean&#8221; here and send a &#8220;card&#8221; downstream to a designer. Hmm, <code>article_ideas += 1</code>.</p>
<p>Anyway, now that we know we have a reliable test suite for this feature, start playing with the UI. With all the cool things available these days like <span class="caps">SASS</span>, Compass, Haml, etc. this step should be fast and easy, even without Photoshop.</p>
<p><img src="/public/images/taddd/nice-login.jpg" title="pretty login screen" alt="pretty login screen" /></p>
<p>So now you have a well tested, functional and quite attractive sign in feature. The cool thing about this approach is that it integrates really well with the normal red, green, refactor methodology. This won&#8217;t be the last sign in feature you write, most likely, so every new one is a chance to not only refactor your code, but also the design.</p>
<p>So if you&#8217;re a designer/developer hybrid or are tasked to doing both, try this out. It&#8217;s helped me get that abstract vision for things into a clearer light, which is always a good thing.</p>
</div>

<div class="article">
    <h2><a href="/2011/03/22/forge-python-fixture-replacement/">Forge - Python Fixture Replacement</a></h2>
    <p>I found myself wanting a simple way to create objects with fake data for unit tests, in Python. I always liked <a href="https://github.com/thoughtbot/factory_girl">factory_girl</a> and the way it keeps things clean and coherent. However, Ruby libraries were no help to me here, directly at least, I needed a Python solution.</p>
<p>I wanted something that wasn&#8217;t fixtures. First of all, I don&#8217;t think you should need a database to run unit tests. If you&#8217;re writing simple, modular code you should be able to give input and test output. So my answer to that need is <a href="https://github.com/mnoble/forge">Forge</a>.</p>
<p>Forge is a very simple object creator loosely based on factory_girl. You define factories and then you build them. What I really like about this approach is that it makes your intent quite obvious. Testing something to with a confirmed user? <code>confirmed_user = Forge('confirmed_user')</code>. Simple, clean and easy to follow.</p>
<p>If you&#8217;re familiar with factory_girl at all, this will be nothing new for you. For those of you who aren&#8217;t, here&#8217;s a quick rundown on how to use Forge.</p>
<h3>Defining Factories</h3>
<p>First create a <code>project/test/factories</code> directory. You can either define all your factories in the <code>__init__.py</code> file or in separate files then import them in <code>__init__.py</code>.</p>
<pre class="clouds">
<span class="Comment"><span class="Comment">#</span> project/test/factories/user.py</span>
<span class="Keyword">from</span> forge <span class="Keyword">import</span> Forge

<span class="Keyword">with</span> Forge.define(<span class="String"><span class="String">'</span>user<span class="String">'</span></span>) <span class="Keyword">as</span> f:
    f.name      <span class="KeywordOperator">=</span> <span class="String"><span class="String">'</span>Matte<span class="String">'</span></span>
    f.age       <span class="KeywordOperator">=</span> <span class="Number">24</span>
    f.confirmed <span class="KeywordOperator">=</span> <span class="BuiltInConstant">False</span>

<span class="Keyword">with</span> Forge.define(<span class="String"><span class="String">'</span>confirmed_user<span class="String">'</span></span>) <span class="Keyword">as</span> f:
    f.name      <span class="KeywordOperator">=</span> <span class="String"><span class="String">'</span>Randy<span class="String">'</span></span>
    f.age       <span class="KeywordOperator">=</span> <span class="Number">67</span>
    f.confirmed <span class="KeywordOperator">=</span> <span class="BuiltInConstant">True</span>
</pre><pre class="clouds">
<span class="Comment"><span class="Comment">#</span> project/test/factories/__init__.py</span>
<span class="Keyword">import</span> user
</pre><h3>Building Forged Objects</h3>
<p>So now that you have a bank of factories for the different scenarios you&#8217;re testing. Time to get down to business. The <span class="caps">API</span> for creating factory objects mimics factory_girl&#8217;s:</p>
<pre class="clouds">
<span class="Keyword">import</span> project.test.factories
<span class="Keyword">from</span> forge <span class="Keyword">import</span> Forge

user <span class="KeywordOperator">=</span> Forge(<span class="String"><span class="String">'</span>user<span class="String">'</span></span>)
<span class="Comment"><span class="Comment">#</span> OR</span>
user <span class="KeywordOperator">=</span> Forge.build(<span class="String"><span class="String">'</span>user<span class="String">'</span></span>)
</pre><p>Unlike factory_girl, Forge will never put your objects into the database. It doesn&#8217;t even know how.</p>
<h3>Using Models</h3>
<p>When you&#8217;re working with an <span class="caps">ORM</span> you usually want objects that are as close to what it returns from a database query. Most of the time this is just achieved by instantiating a model class with your factory data. And that is exactly what Forge does. You can configure Forge to use a specific module to retrieve models from:</p>
<pre class="clouds">
Forge.configure(<span class="FunctionArgument">models</span><span class="KeywordOperator">=</span><span class="String"><span class="String">'</span>project.models<span class="String">'</span></span>)
</pre><p>Now, when you try to build a <code>user</code> factory, it will try to import <code>project.models.User</code>. If it exists, it will create an instance of it and apply the factory data to it. As long as your model&#8217;s constructor takes <code>**kwargs</code> of attributes, Forge should work just fine.</p>
<h3>Wrap Up</h3>
<p>Forge isn&#8217;t anything fancy, but it provides a uniform way to define and create real objects for tests. It keeps things organized, the intent clear and works out of the box. If you find yourself wanting to ditch the database in your unit tests, check it out.</p>
</div>

            </div>
            
            <div style="clear:both;"></div> 
            
            <ul id="article-nav">
            
                <li id="previous"><a href="/page2">&laquo; Previous</a></li>
            
            
            
            </ul>
        </div>
        
        <div id="sidebar">
            <p id="bio">
                I'm Matte Noble, a Software Developer, Ruby
                enthusiast, Metalhead and all around curious guy.
                This is where I share things I know and learn.
            </p>
            
            <ul>
                <li id="archive"><a href="/archive">Archive</a></li>
                <li id="rss"><a href="http://feeds.feedburner.com/mattenoble">RSS</a></li>
                <li id="twitter"><a href="http://twitter.com/mattenoble">@mattenoble</a></li>
                <li id="github"><a href="http://github.com/mnoble">github.com/mnoble</a></li>
            </ul>
        </div>
    </div>
</body>
</html>